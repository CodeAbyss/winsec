

/**
 *
 *  class for obtaining syskey required to decrypt LSA database key
 *
 */

#include "Syskey.h"

/**
 *
 *   generate system key from pass phrase -> level 2
 *
 *   Function called ConfirmPasswordDlg() in SYSKey.exe
 *
 */

BOOL SysKey::SetFromPassword(std::wstring pwd) {
  HCRYPTPROV hProv;
  HCRYPTHASH hHash;

  if (CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,
      CRYPT_VERIFYCONTEXT)) {
    if (CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash)) {
      if (CryptHashData(hHash, (PBYTE)pwd.c_str(),
          pwd.length() * sizeof(wchar_t), 0)) {

        DWORD dwHashLen = SYSTEM_KEY_LEN;
        CryptGetHashParam(hHash, HP_HASHVAL, key, &dwHashLen, 0);
        dwError = GetLastError();
      }
      CryptDestroyHash(hHash);
    } else {
      dwError = GetLastError();
    }
    CryptReleaseContext(hProv, 0);
  } else {
    dwError = GetLastError();
  }
  return dwError == ERROR_SUCCESS;
}

/**
 *
 * get random 16-byte system key from file.
 * default location is A:\Startkey.key
 *
 */

bool Syskey::GetFromFile(wchar_t szFile[])
{
  HANDLE hFile;
  bool bStatus = false;

  if ((hFile = CreateFileW(szFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)) != INVALID_HANDLE_VALUE)
  {
    DWORD dwRead = 0;
    bStatus = ((ReadFile(hFile,syskey,16,&dwRead,NULL)) && dwRead == 16);
    CloseHandle(hFile);
  } else dwError = GetLastError();

  return bStatus;
}

/**
 *
 *  Reads DWORD value of subkey "Default" in rootkey "HKEY_LOCAL_MACHINE\SYSTEM\Select"
 *
 *  All entries are:
 *
 *    Current
 *    Default
 *    Failed
 *    LastKnownGood
 *
 */

DWORD Syskey::GetControlIndex()
{
  DWORD dwSize = sizeof(DWORD);
  HKEY hSubKey;
  wchar_t path[MAX_PATH];

  wsprintfW(path,L"%s\\Select",lpszHiveNames[SYSTEM_KEY]);

  if ((dwError = RegOpenKeyExW(hRegistry,path,0,KEY_QUERY_VALUE,&hSubKey)) == ERROR_SUCCESS)
  {
    dwError = RegQueryValueExW(hSubKey,L"Default",NULL,NULL,reinterpret_cast<BYTE*>(&dwControlIndex),&dwSize);
    RegCloseKey(hSubKey);
  }

  return dwControlIndex;
}

/**
 *
 *  Query SecureBoot value at System\\CurrentControlSet\\Control\\Lsa
 *
 *  Syskey levels were verified with XP Professional
 *
 *    0 - Not enabled
 *    1 - Random key generated by OS, stored in registry, default on all OS since windows 2000
 *    2 - Derived from password chosen by administrator, stored in administrators brain ;-)
 *    3 - Random key generated by OS, stored on floppy disk
 *
 */

DWORD Syskey::GetKeyType()
{
  DWORD dwSize = sizeof(DWORD);
  HKEY hSubKey;
  wchar_t path[MAX_PATH];

  GetControlIndex();

  wsprintfW(path,L"%s\\ControlSet%03i\\Control\\Lsa",lpszHiveNames[SYSTEM_KEY],dwControlIndex);

  if ((dwError = RegOpenKeyExW(hRegistry,path,0,KEY_QUERY_VALUE,&hSubKey)) == ERROR_SUCCESS)
  {
    dwError = RegQueryValueExW(hSubKey,L"SecureBoot",NULL,NULL,reinterpret_cast<BYTE*>(&dwKeyType),&dwSize);
    RegCloseKey(hSubKey);
  }
  
  return dwKeyType;
}

/**
 *
 *  Query class values of subkeys at HKEY_LOCAL_MACHINE\System\ControlSet00X\Control\Lsa
 *
 */
bool Syskey::GetFromRegistry()
{
  const wchar_t *szSubKeys[4]={ L"JD", L"Skew1", L"GBG", L"Data" };

  // shuffle bytes found in xp syskey binary
  unsigned char xp[16] =  { 0x08, 0x05, 0x04, 0x02, 0x0b, 0x09, 0x0d, 0x03,
                            0x00, 0x06, 0x01, 0x0c, 0x0e, 0x0a, 0x0f, 0x07 };

  unsigned char result[16]={0};
  unsigned char* p = result;

  // for each subkey
  for(int i = 0;i < 4;i++) {
    wchar_t path[MAX_PATH];
    HKEY hSubKey;

    wsprintfW(path,L"%s\\ControlSet%03i\\Control\\Lsa\\%s",lpszHiveNames[SYSTEM_KEY],dwControlIndex,szSubKeys[i]);

    if ((dwError = RegCreateKeyExW(hRegistry,path,0,NULL,REG_OPTION_BACKUP_RESTORE,KEY_QUERY_VALUE,NULL,&hSubKey,NULL)) == ERROR_SUCCESS) {
      wchar_t classInfo[MAX_PATH];
      DWORD cClass = MAX_PATH;

      // if query classinfo good
      if ((dwError = RegQueryInfoKeyW(hSubKey,classInfo,&cClass,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL)) == ERROR_SUCCESS) {
        int value = 0;

        // convert class ascii hex to binary and save
        for (int j(0);j < 4;j++) {
          swscanf(reinterpret_cast<const wchar_t*>(&classInfo[j*2]),L"%02x",&value);
          *p++ = value;
        }
      } else break;
    }
    RegCloseKey(hSubKey);
  }

  // if we got 16 bytes
  if (p - result == 16) {
    // shuffle and save
    for (int i(0);i < 16;i++)
         syskey[i] = result[ xp[i] ];
  }
  return dwError == ERROR_SUCCESS;
}

// need to change return value - to indicate unknown value...although "highly enlikely hey"
bool Syskey::GetSyskey(wchar_t param[])
{
  switch(dwKeyType)
  {
    case DISABLED:
      return false;   // syskey isn't enabled
    case REGISTRY:
      return GetFromRegistry();
    case PASSWORD:
      return GetFromPassword(param);
    case FLOPPY:
      return GetFromFile(param);
    default:
      return false;     // unknown syskey type
  }
}
